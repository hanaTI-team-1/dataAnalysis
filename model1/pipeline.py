# -*- coding: utf-8 -*-
"""pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BsioXzaCuvRjcX6g3eCcEA3q0FWYrWZV

{
            "atclNo": "2433784438",
            "cortarNo": "1150010500",
            "atclNm": "마곡일성트루엘플래닛",
            "atclStatCd": "R0",
            "rletTpCd": "A02",
            "uprRletTpCd": "A02",
            "rletTpNm": "오피스텔",
            "tradTpCd": "A1",
            "tradTpNm": "매매",
            "vrfcTpCd": "OWNER",
            "flrInfo": "13/14",
            "prc": 41000,
            "rentPrc": 0,
            "hanPrc": "4억 1,000",
            "spc1": "96",
            "spc2": "42.86",
            "direction": "남향",
            "atclCfmYmd": "24.07.09.",
            "repImgUrl": "/20240709_33/land_naver_1720508229484uxIok_JPEG/20200728_182536_1.jpg",
            "repImgTpCd": "10",
            "repImgThumb": "f130_98",
            "lat": 37.568732,
            "lng": 126.825344,
            "atclFetrDesc": "마곡코엑스 인근. 실입주가능. 로얄호수 1.5룸",
            "tag1": "10년이내",
            "tag2": "역세권",
            "tag3": "화장실한개",
            "bildNm": "A동",
            "minute": "0",
            "sameAddrCnt": 2,
            "sameAddrDirectCnt": 1,
            "cpid": "bizmk",
            "cpNm": "매경부동산",
            "cpCnt": 2,
            "rltrNm": "마곡보타닉공인중개사사무소",
            "sellrNm": null,
            "directTradYn": "N",
            "minMviFee": 0,
            "maxMviFee": 0,
            "etRoomCnt": 0,
            "tradePriceHan": null,
            "tradeRentPrice": 0,
            "tradeCheckedByOwner": "false",
            "cpLinkVO": null,
            "dtlAddrYn": "N",
            "dtlAddr": null,
            "address": "서울 강서구 마곡동 758-2"
        },

Index(['Unnamed: 0.1', 'Unnamed: 0', 'value', '발생', '검거', 'cggCd', 'stdgCd',
       'mno', 'sno', 'flr', 'ctrtDay', 'rentArea', 'grfe', 'rtfe', 'bldgUsg',
       'newUpdtYn', 'ctrtUpdtUseYn', 'bfrGrfe', 'lat', 'lon', '자치구명_강남구',
       '자치구명_강서구', '자치구명_관악구', '자치구명_동작구', '자치구명_송파구', 'ctrtDayMonth',
       '500m_내_초중등수', '500m_내_bus수', '500m_내_마트수', 'Closest_Station_Distance'],
      dtype='object')
"""

json_data={
            "atclNo": "2433784438",
            "cortarNo": "1150010500",
            "atclNm": "마곡일성트루엘플래닛",
            "atclStatCd": "R0",
            "rletTpCd": "A02",
            "uprRletTpCd": "A02",
            "rletTpNm": "오피스텔",
            "tradTpCd": "A1",
            "tradTpNm": "매매",
            "vrfcTpCd": "OWNER",
            "flrInfo": "13/14",
            "prc": 41000,
            "rentPrc": 0,
            "hanPrc": "4억 1,000",
            "spc1": "96",
            "spc2": "42.86",
            "direction": "남향",
            "atclCfmYmd": "24.07.09.",
            "repImgUrl": "/20240709_33/land_naver_1720508229484uxIok_JPEG/20200728_182536_1.jpg",
            "repImgTpCd": "10",
            "repImgThumb": "f130_98",
            "lat": 37.568732,
            "lng": 126.825344,
            "atclFetrDesc": "마곡코엑스 인근. 실입주가능. 로얄호수 1.5룸",
            "tag1": "10년이내",
            "tag2": "역세권",
            "tag3": "화장실한개",
            "bildNm": "A동",
            "minute": "0",
            "sameAddrCnt": 2,
            "sameAddrDirectCnt": 1,
            "cpid": "bizmk",
            "cpNm": "매경부동산",
            "cpCnt": 2,
            "rltrNm": "마곡보타닉공인중개사사무소",
            "sellrNm": "",
            "directTradYn": "N",
            "minMviFee": 0,
            "maxMviFee": 0,
            "etRoomCnt": 0,
            "tradePriceHan": "",
            "tradeRentPrice": 0,
            "tradeCheckedByOwner": "false",
            "cpLinkVO": "",
            "dtlAddrYn": "N",
            "dtlAddr": "",
            "address": "서울 강서구 마곡동 758-2"
        }
input_df = pd.DataFrame([json_data])

print(input_df)

input_df



from flask import Flask, request, jsonify
import pandas as pd
import sys
import json

def process_json(json_str):
    json_data = json.loads(json_str)
    print(json_data)

# app = Flask(__name__) #엔드포인트
# @app.route('/json-to-df', methods=['POST'])

# import oracledb

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import seaborn as sns
import warnings
import matplotlib.pyplot as plt
warnings.filterwarnings("ignore")
from matplotlib.ticker import StrMethodFormatter,FormatStrFormatter
pd.options.display.float_format = '{:.5f}'.format
plt.style.use("seaborn-whitegrid")
import seaborn as sns
from sklearn.preprocessing import KBinsDiscretizer
import datetime as dt
from datetime import datetime
from sklearn.preprocessing import LabelEncoder
from geopy.distance import distance
from geopy.distance import geodesic

# bldgUsg 변환함수
def convert_new_bldgUsg(bldgUsg):
    if bldgUsg == '아파트':
        return 1
    elif bldgUsg == '연립다세대':
        return 2
    else:
        return 3  # 예외 처리

  # 신규계약구분을 1과 0으로 변환하는 함수
def convert_new_contract_type(contract_type):
    if contract_type == '신규':
        return 1
    elif contract_type == '갱신':
        return 0
    else:
        return None  # 예외 처리

# 날짜 형식을 통일하는 함수
def format_date(date_str):
    if len(date_str.split('.')[0]) == 2:
        return '20' + date_str
    return date_str

# 가장 가까운 지하철역의 거리를 계산하는 함수
def find_closest_station_distance(lat, lon, station_df):
    min_distance = float('inf')
    closest_station = None
    for _, station in station_df.iterrows():
        dist = geodesic((lat, lon), (station['lat'], station['lng'])).kilometers
        if dist < min_distance:
            min_distance = dist
            closest_station = station['name']
    return min_distance, closest_station


def transfer(input_df):
   input_df=input_df[['value', '발생', '검거', 'cggCd', 'stdgNm','ctrtPrd'
       'mno', 'sno', 'flr', 'ctrtDay', 'rentArea', 'grfe', 'rtfe', 'bldgUsg',
       'newUpdtYn', 'ctrtUpdtUseYn', 'bfrGrfe', 'lat', 'lon', '자치구명_강남구',
       '자치구명_강서구', '자치구명_관악구', '자치구명_동작구', '자치구명_송파구', 'ctrtDayMonth',
       '500m_내_초중등수', '500m_내_bus수', '500m_내_마트수', 'Closest_Station_Distance']]
  # input_df.drop(columns='bfrRtfe',inplace=True)
  # # 종전임대료 drop
  # input_df.drop(columns='stdgNm',inplace=True) #법정동명 drop

  #자치구명 원핫 인코더
  # 자치구명 리스트
  districts = ['강남구', '강서구', '관악구', '동작구', '송파구']

  # 원핫 인코딩 컬럼 생성
  for district in districts:
      input_df[f'자치구명_{district}'] = (input_df['cggNm'] == district).astype(int)

  # input_df.drop(columns='rtfe',inplace=True)
  #임대료 drop
  # input_df.drop(columns='lotnoSe',inplace=True) #지번구분 drop
  # input_df.drop(columns='archYr',inplace=True) #건축년도 drop
  # input_df.drop(columns='lotnoSeNm',inplace=True) #전월세 구분 drop 다 전세여서
  # input_df.drop(columns='bldgNm',inplace=True)  # 건물명 drop
  # # input_df.drop(columns='ctrtPrd',inplace=True)
  # # ctrtPrd
  # input_df.drop(columns='rcptYr',inplace=True)  # 계약기간 drop
  # input_df.drop(columns='rentSe',inplace=True)  # rentSe drop

  # apply 함수를 사용하여 변환 적용
  input_df['newUpdtYn'] = input_df['newUpdtYn'].apply(convert_new_contract_type)

  #계약일 날짜로 변환
  current =  datetime.now()
  input_df["ctrtDay"] = current - pd.to_datetime(input_df["ctrtDay"],format='%Y%m%d')
  input_df["ctrtDay"] = input_df["ctrtDay"].dt.days

  input_df['시작일'] = input_df['ctrtPrd'].str.split('~').str[0]
  input_df['종료일'] = input_df['ctrtPrd'].str.split('~').str[1]

  input_df = input_df.dropna(subset=['시작일'])
  input_df = input_df.dropna(subset=['종료일'])

  # "."으로 시작하는 데이터 제거
  input_df = input_df[~input_df['시작일'].str.startswith('.')]
  input_df = input_df[~input_df['종료일'].str.startswith('.')]

  # 날짜 형식을 통일
  input_df['시작일'] = input_df['시작일'].apply(format_date)
  input_df['종료일'] = input_df['종료일'].apply(format_date)

  # 문자열을 datetime 형식으로 변환
  input_df['시작일'] = pd.to_datetime(input_df['시작일'], format="%Y.%m")
  input_df['종료일'] = pd.to_datetime(input_df['종료일'], format="%Y.%m")

  # 두 날짜 사이의 차이 계산 (월 단위)
  input_df['ctrtDayMonth'] = (input_df['종료일'].dt.year - input_df['시작일'].dt.year) * 12 + (input_df['종료일'].dt.month - input_df['시작일'].dt.month)
  input_df.drop(columns='시작일',inplace=True)
  input_df.drop(columns='종료일',inplace=True)
  input_df.drop(columns='ctrtPrd',inplace=True)
  input_df['ctrtDayMonth']
  input_df['bldgUsg'] = input_df['bldgUsg'].apply(convert_new_bldgUsg)
  input_df['ctrtUpdtUseYn'] = input_df['ctrtUpdtUseYn'].apply(lambda x: 1 if x == '○' else 0)
  input_df = input_df.dropna(subset=['newUpdtYn'])
  input_df = input_df.dropna(subset=['bfrGrfe'])
  return input_df

#데이터 불러오고 전처리
# 모든 데이터 Latitude,Longitude 로 바꾸기
school_df=pd.read_csv("schooldf경로",encoding='cp949') #school_df=school_df[['위도','경도']]->lati~
newdata=pd.read_csv("",encoding='cp949')
bus_df=pd.read_csv("",encoding='cp949')
bus_df=bus_df[['X좌표','Y좌표']]
shop_df=pd.read_csv("",encoding='cp949')#shop_df[['Latitude','Longitude']]
sub_df=pd.read_csv("",encoding='cp949')# station_df.dropna(subset=['lat'],inplace=True) 지하철 데이터 이거해서 넣어두기
# station_df=station_df[['lat','lng','name']] 이거 [['Latitude','Longitude']] 이걸로 바꿔서 넣기
con_df=pd.read_csv("",encoding='cp949') #condate=condate[['Latitude','Longitude']]
crime_df=pd.read_csv("",encoding='cp949')

school_df=transfer(school_df)
newdata=transfer(newdata)

#금리데이터 붙이기

inte_rate=pd.read_csv("/content/drive/MyDrive/A하금티/data/inte_rate.csv",encoding='cp949')
inte_rate=inte_rate[['TIME','value']]
inte_rate=inte_rate.drop_duplicates(['TIME'], keep='first')

newdata=newdata.merge(inte_rate, how='left', left_on='ctrtDay', right_on='TIME')

newdata = newdata.reset_index(drop=True)
school_df = school_df.reset_index(drop=True)
bus_df = bus_df.reset_index(drop=True)
con_df = con_df.reset_index(drop=True)
sub_df = sub_df.reset_index(drop=True)


# 데이터프레임 결합
df1 = pd.concat([newdata, school_df['500m_내_초중등수']], axis=1)
df2 = pd.concat([df1, bus_df['500m_내_bus수']], axis=1)
df3 = pd.concat([df2, con_df['500m_내_마트수']], axis=1)
df4 = pd.concat([df3, sub_df['Closest_Station_Distance']], axis=1)

# 필터링할 자치구명
desired_gu = ['관악구', '송파구', '강서구', '강남구', '동작구']

# 자치구명 필터링
crime_df = crime_df[newdata['cggNm'].isin(desired_gu)]

crime=newdata.merge(crime_df, how='left', left_on='cggNm', right_on='자치구별')
newdata=transfer(newdata)
crime=transfer(crime)
crime=crime[['발생','검거']]

crime = crime.reset_index(drop=True)
df4 = df4.reset_index(drop=True)
df5=pd.concat([crime,df4],axis=1)



# 모델링에 들어가기 위한 최종 전처리

Y= df[['grfe']]
X= df.drop(columns=['Unnamed: 0', 'grfe'])
clist=X.columns

#데이터와 테스트 데이터 분리
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)


# 모델링 시작

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression

# 모델 불러와서 예측값 계산하고 계산값 백으로 리턴하기

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python a.py 'json_data'")
        sys.exit(1)

    json_data_str = sys.argv[1]
    process_json(json_data_str)

"""# new pipe"""

import sys
import json
import pandas as pd
import numpy as np
from datetime import datetime
from sklearn.linear_model import LinearRegression
import joblib

# 전처리 함수 정의
def convert_new_bldgUsg(bldgUsg):
    if bldgUsg == '아파트':
        return 1
    elif bldgUsg == '연립다세대':
        return 2
    else:
        return 3  # 예외 처리
# 가장 가까운 지하철역의 거리를 계산하는 함수
def find_closest_station_distance(lat, lon, station_df):
    min_distance = float('inf')
    closest_station = None
    for _, station in station_df.iterrows():
        dist = geodesic((lat, lon), (station['lat'], station['lng'])).kilometers
        if dist < min_distance:
            min_distance = dist
            closest_station = station['name']
    return min_distance, closest_station

def convert_new_contract_type(contract_type):
    if contract_type == '신규':
        return 1
    elif contract_type == '갱신':
        return 0
    else:
        return None  # 예외 처리

def format_date(date_str):
    if len(date_str.split('.')[0]) == 2:
        return '20' + date_str
    return date_str

def count_nearby(lat, lon,df):
      count = 0
      for _, store in condate.iterrows():
          dist = geodesic((lat, lon), (df['Latitude'], df['Longitude'])).km
          if dist <= 0.5:
               count += 1
      return count

def transfer(input_df):

    input_df.drop(columns='bfrRtfe', inplace=True)
    input_df.drop(columns='stdgNm', inplace=True)
    districts = ['강남구', '강서구', '관악구', '동작구', '송파구']
    for district in districts:
        input_df[f'자치구명_{district}'] = (input_df['cggNm'] == district).astype(int)
    input_df.drop(columns='lotnoSe', inplace=True)
    input_df.drop(columns='archYr', inplace=True)
    input_df.drop(columns='lotnoSeNm', inplace=True)
    input_df.drop(columns='bldgNm', inplace=True)
    input_df.drop(columns='rcptYr', inplace=True)
    input_df.drop(columns='rentSe', inplace=True)
    input_df['newUpdtYn'] = input_df['newUpdtYn'].apply(convert_new_contract_type)
    current = datetime.now()
    input_df["ctrtDay"] = current - pd.to_datetime(input_df["ctrtDay"], format='%Y%m%d')
    input_df["ctrtDay"] = input_df["ctrtDay"].dt.days
    input_df['시작일'] = input_df['ctrtPrd'].str.split('~').str[0]
    input_df['종료일'] = input_df['ctrtPrd'].str.split('~').str[1]
    input_df = input_df.dropna(subset=['시작일', '종료일'])
    input_df = input_df[~input_df['시작일'].str.startswith('.')]
    input_df = input_df[~input_df['종료일'].str.startswith('.')]
    input_df['시작일'] = input_df['시작일'].apply(format_date)
    input_df['종료일'] = input_df['종료일'].apply(format_date)
    input_df['시작일'] = pd.to_datetime(input_df['시작일'], format="%Y.%m")
    input_df['종료일'] = pd.to_datetime(input_df['종료일'], format="%Y.%m")
    input_df['ctrtDayMonth'] = (input_df['종료일'].dt.year - input_df['시작일'].dt.year) * 12 + (input_df['종료일'].dt.month - input_df['시작일'].dt.month)
    input_df.drop(columns=['시작일', '종료일', 'ctrtPrd'], inplace=True)
    input_df['bldgUsg'] = input_df['bldgUsg'].apply(convert_new_bldgUsg)
    input_df['ctrtUpdtUseYn'] = input_df['ctrtUpdtUseYn'].apply(lambda x: 1 if x == '○' else 0)
    input_df = input_df.dropna(subset=['newUpdtYn', 'bfrGrfe'])


    #데이터 불러오고 전처리
  # 모든 데이터 Latitude,Longitude 로 바꾸기
  school_df=pd.read_csv("schooldf경로",encoding='cp949') #school_df=school_df[['위도','경도']]->lati~
  newdata=pd.read_csv("",encoding='cp949')
  bus_df=pd.read_csv("",encoding='cp949')
  bus_df=bus_df[['X좌표','Y좌표']]
  shop_df=pd.read_csv("",encoding='cp949')#shop_df[['Latitude','Longitude']]
  sub_df=pd.read_csv("",encoding='cp949')# station_df.dropna(subset=['lat'],inplace=True) 지하철 데이터 이거해서 넣어두기
  # station_df=station_df[['lat','lng','name']] 이거 [['Latitude','Longitude']] 이걸로 바꿔서 넣기
  con_df=pd.read_csv("",encoding='cp949') #condate=condate[['Latitude','Longitude']]
  police_df=pd.read_csv("",encoding='cp949')
  #police_df=police_df[['Latitude','Longitude']]
  crime_df=pd.read_csv("",encoding='cp949')
  # 필터링할 자치구명
  desired_gu = ['관악구', '송파구', '강서구', '강남구', '동작구']
  # 자치구명 필터링
  crime_df = crime_df[crime_df['자치구별'].isin(desired_gu)]

  school_df=transfer(school_df)
  newdata=transfer(newdata)

        # 인프라 계산


    # 입력 데이터프레임에 반경 1킬로미터 내 편의점 수 열 추가
    newdata['500m_내_편의점_수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon']), axis=1)

    # 입력 데이터프레임에 가장 가까운 지하철역 거리 열 추가
    newdata['Closest_Station_Distance'] = newdata.apply(lambda row: find_closest_station_distance(row['lat'], row['lon'], station_df)[0], axis=1)

    newdata['500m_내_마트수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon']), axis=1)
    newdata['500m_내_초중등수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon']), axis=1)
    input_df['500m_내_bus수'] = input_df.apply(lambda row: count_nearby(row['lat'], row['lon']), axis=1)
  input_df = input_df.merge(crime_df, how='left', left_on='자치구명', right_on='자치구별')
  input_df['500m_내_경찰서수'] = input_df.apply(lambda row: count_nearby(row['lat'], row['lon']), axis=1)

    return input_df

def process_json(json_str):
    json_data = json.loads(json_str)
    input_df = pd.DataFrame([json_data])
    input_df = transfer(input_df)
    return input_df

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python a.py 'json_data'")
        sys.exit(1)

    json_data_str = sys.argv[1]
    input_df = process_json(json_data_str)

# Load pre-trained model
    model = load_model('final_model_pycaret')

    # Make predictions
    predictions = predict_model(model, data=input_df)

    # Return predictions
    print(predictions[['Label']].to_json(orient='records'))

"""## newnew"""

!pip install pycaret

# !pip install pycaret
import json
import pandas as pd
from geopy.distance import geodesic
from pycaret.regression import load_model, predict_model

inte_rate=pd.read_csv("/content/drive/MyDrive/A하금티/data/inte_rate.csv",encoding='cp949')

inte_rate

"atclCfmYmd": "24.07.09.",

inte_rate

# !pip install pycaret
import json
import pandas as pd
from geopy.distance import geodesic
from pycaret.regression import load_model, predict_model

# 전처리 함수 정의
def convert_new_bldgUsg(bldgUsg):
    if bldgUsg == '아파트':
        return 1
    elif bldgUsg == '연립다세대':
        return 2
    else:
        return 3  # 예외 처리
# "atclCfmYmd" 값을 "20240709" 형식으로 변환하는 함수
def convert_date(date_str):
    parts = date_str.split('.')
    year = "20" + parts[0]
    month = parts[1].zfill(2)
    day = parts[2].zfill(2)
    return year + month + day

# 가장 가까운 지하철역의 거리를 계산하는 함수
def find_closest_station_distance(lat, lon, station_df):
  min_distance = float('inf')
  for i, station in station_df.iterrows():
    dist = geodesic((lat, lon), (station['Latitude'], station['Longitude'])).kilometers
    if dist < min_distance:
      min_distance = dist
  return min_distance

def convert_new_contract_type(contract_type):
    if contract_type == '신규':
        return 1
    elif contract_type == '갱신':
        return 0
    else:
        return None  # 예외 처리

def format_date(date_str):
    if len(date_str.split('.')[0]) == 2:
        return '20' + date_str
    return date_str

def count_nearby(lat, lon, df):
    count = 0
    for _, dff in df.iterrows():
        dist = geodesic((lat, lon), (dff['Latitude'], dff['Longitude'])).km
        if dist <= 0.5:
            count += 1
    return count

  # 주소에서 구, 본번, 부번 추출하는 함수 정의
def extract_address_parts(address):
    address_parts = address.split()
    gu = address_parts[1]  # '구'
    dong = address_parts[2]  # '구'
    main_number_subnumber = address_parts[-1]  # '본번-부번'
    main_number, sub_number = main_number_subnumber.split('-')
    return gu, dong,main_number, sub_number


def transfer(input_df):
  # districts = ['강남구', '강서구', '관악구', '동작구', '송파구']
    # 데이터 전처리 작업
  # input_df=input_df[['cggCd','stdgCd','ctrtPrd','mno','sno','flr','ctrtDay','rentArea','grfe','rtfe','bldgUsg',
  #                   'newUpdtYn','ctrtUpdtUseYn','bfrGrfe','lat', 'lon']]
  # flrInfo -> flr에서 '/' 앞에 값만 추출
  input_df['flrInfo'] = input_df['flrInfo'].apply(lambda x: int(x.split('/')[0]))
  input_df=input_df[['rletTpNm','flrInfo','prc','spc1','lat','lng','address','atclCfmYmd']]



  # apply 함수를 사용하여 각 행에 함수 적용
  input_df[['cggNm', 'stdgNm','mno', 'sno']] = input_df['address'].apply(lambda x: pd.Series(extract_address_parts(x)))



  # 열 이름 변경
  input_df.rename(columns={
      'flrInfo':'flr',
      'spc1':'rentArea',
      'prc' :'grfe',
      'rletTpNm':'bldgUsg'
  }, inplace=True)

  print("열이름변경 ")
  print(input_df)
  # for district in districts:
  #   input_df[f'자치구명_{district}'] = (input_df['cggNm'] == district).astype(int)

  # input_df.drop(columns='lotnoSe', inplace=True)
  # input_df.drop(columns='archYr', inplace=True)
  # input_df.drop(columns='lotnoSeNm', inplace=True)
  # input_df.drop(columns='bldgNm', inplace=True)
  # input_df.drop(columns='rcptYr', inplace=True)
  # input_df.drop(columns='rentSe', inplace=True)
  # input_df['newUpdtYn'] = input_df['newUpdtYn'].apply(convert_new_contract_type)
  current = pd.to_datetime('now')
  inte_rate=pd.read_csv("/content/drive/MyDrive/A하금티/data/inte_rate.csv",encoding='cp949')
  inte_rate=inte_rate.drop_duplicates(['TIME'], keep='first')
  input_df['atclCfmYmd'] = input_df['atclCfmYmd'].apply(convert_date)
  # atclCfmYmd 열을 문자열으로 변환
  input_df['atclCfmYmd'] = input_df['atclCfmYmd'].astype(str)
  inte_rate['TIME'] = inte_rate['TIME'].astype(str)
  print(input_df['atclCfmYmd'])
  input_df=input_df.merge(inte_rate, how='left', left_on='atclCfmYmd', right_on='TIME')
  print(input_df)
  # input_df['시작일'] = input_df['ctrtPrd'].str.split('~').str[0]
  # input_df['종료일'] = input_df['ctrtPrd'].str.split('~').str[1]
  # input_df = input_df.dropna(subset=['시작일', '종료일'])
  # input_df = input_df[~input_df['시작일'].str.startswith('.')]
  # input_df = input_df[~input_df['종료일'].str.startswith('.')]
  # input_df['시작일'] = input_df['시작일'].apply(format_date)
  # input_df['종료일'] = input_df['종료일'].apply(format_date)
  # input_df['시작일'] = pd.to_datetime(input_df['시작일'], format="%Y.%m")
  # input_df['종료일'] = pd.to_datetime(input_df['종료일'], format="%Y.%m")
  # input_df['ctrtDayMonth'] = (input_df['종료일'].dt.year - input_df['시작일'].dt.year) * 12 + (input_df['종료일'].dt.month - input_df['시작일'].dt.month)
  # input_df.drop(columns=['시작일', '종료일', 'ctrtPrd'], inplace=True)
  input_df['bldgUsg'] = input_df['bldgUsg'].apply(convert_new_bldgUsg)
  # input_df['ctrtUpdtUseYn'] = input_df['ctrtUpdtUseYn'].apply(lambda x: 1 if x == '○' else 0)
  # input_df = input_df.dropna(subset=['newUpdtYn', 'bfrGrfe'])
  return input_df


def infra(newdata):
  print(newdata,"infra에 들어옴")
  school_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/school_filtered.csv",encoding='utf-8')
  bus_df=pd.read_excel("/content/drive/MyDrive/A하금티/data/bus_seoul_filtered.xlsx")
  shop_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/market.csv",encoding='utf-8')
  sub_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/station.csv",encoding='utf-8')
  sub_df.dropna(subset=['Latitude'],inplace=True)

  crime_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/crime.csv",encoding='utf-8')
  police_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/police_add_lo.csv",encoding='utf-8')


    # 자치구명 필터링
  desired_gu = ['관악구', '송파구', '강서구', '강남구', '동작구']
  crime_df = crime_df[crime_df['자치구별'].isin(desired_gu)]

    # 각 데이터 전처리
  # school_df = transfer(school_df)
  # newdata = transfer(newdata)

    # 인프라 계산 및 입력 데이터프레임에 추가
  # newdata['500m_내_편의점_수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon'], shop_df), axis=1)
  newdata['Closest_Station_Distance'] = find_closest_station_distance(newdata['lat'].iloc[0], newdata['lng'].iloc[0], sub_df)
  newdata['500m_내_마트수'] = count_nearby(newdata['lat'].iloc[0], newdata['lng'].iloc[0], shop_df)
  newdata['500m_내_초중등수'] = count_nearby(newdata['lat'].iloc[0], newdata['lng'].iloc[0], school_df)
  newdata['500m_내_bus수'] = count_nearby(newdata['lat'].iloc[0], newdata['lng'].iloc[0], bus_df)
  newdata['500m_내_경찰서수'] = count_nearby(newdata['lat'].iloc[0], newdata['lng'].iloc[0], police_df)
  newdata = newdata.merge(crime_df, how='left', left_on='cggNm', right_on='자치구별')
  print("다합침")
  print(newdata)
  # newdata['500m_내_bus수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon'], bus_df), axis=1)
  # newdata = newdata.merge(crime_df, how='left', left_on='자치구명', right_on='자치구별')
  # newdata['500m_내_경찰서수'] = newdata.apply(lambda row: count_nearby(row['lat'], row['lon'], police_df), axis=1)
  selected_features = ['value', '발생', '검거', 'cggNm', 'stdgNm', 'mno', 'sno', 'flr', 'rentArea',
       'grfe', 'bldgUsg', 'lat', 'lng', '500m_내_초중등수', '500m_내_bus수',
       '500m_내_마트수', 'Closest_Station_Distance']
  newdata = newdata[selected_features]
  print(newdata.columns)
  return newdata

def process_json(json_str):
  json_data = json.loads(json_str)
  input_df = pd.DataFrame([json_data])
  input_df = transfer(input_df)
  return input_df

# 예측 함수
def predict(input_df):
    print("모델로 들어옴")
    print(input_df)
    # 모델 로드
    model = load_model('/content/drive/MyDrive/A하금티/data/final_lgbm_pycaret')
    print(input_df['grfe'])
    input_df.rename(columns={'lng':'lon'}, inplace=True)
    Y= input_df[['grfe']]
    X= input_df.drop(columns=['grfe'])
    # 모델 예측
    predictions = model.predict(X)

    return predictions

if __name__ == "__main__":
    # JSON 데이터가 첫 번째 인자로 전달됨을 가정
    json_data_str = """
    {
        "atclNo": "2433784438",
        "cortarNo": "1150010500",
        "atclNm": "마곡일성트루엘플래닛",
        "atclStatCd": "R0",
        "rletTpCd": "A02",
        "uprRletTpCd": "A02",
        "rletTpNm": "오피스텔",
        "tradTpCd": "A1",
        "tradTpNm": "매매",
        "vrfcTpCd": "OWNER",
        "flrInfo": "13/14",
        "prc": 41000,
        "rentPrc": 0,
        "hanPrc": "4억 1,000",
        "spc1": "96",
        "spc2": "42.86",
        "direction": "남향",
        "atclCfmYmd": "24.07.08.",
        "repImgUrl": "/20240709_33/land_naver_1720508229484uxIok_JPEG/20200728_182536_1.jpg",
        "repImgTpCd": "10",
        "repImgThumb": "f130_98",
        "lat": 37.568732,
        "lng": 126.825344,
        "atclFetrDesc": "마곡코엑스 인근. 실입주가능. 로얄호수 1.5룸",
        "tag1": "10년이내",
        "tag2": "역세권",
        "tag3": "화장실한개",
        "bildNm": "A동",
        "minute": "0",
        "sameAddrCnt": 2,
        "sameAddrDirectCnt": 1,
        "cpid": "bizmk",
        "cpNm": "매경부동산",
        "cpCnt": 2,
        "rltrNm": "마곡보타닉공인중개사사무소",
        "sellrNm": "",
        "directTradYn": "N",
        "minMviFee": 0,
        "maxMviFee": 0,
        "etRoomCnt": 0,
        "tradePriceHan": "",
        "tradeRentPrice": 0,
        "tradeCheckedByOwner": "false",
        "cpLinkVO": "",
        "dtlAddrYn": "N",
        "dtlAddr": "",
        "address": "서울 강서구 마곡동 758-2"
    }
    """

    # JSON 데이터를 처리하여 DataFrame으로 변환
    input_df = process_json(json_data_str)
    input_df=infra(input_df)
    print("인프라끝")
    print(input_df)
    # 예측 수행
    predictions = predict(input_df)

    # 예측 결과 출력
    print(predictions.tolist())

newdata

school_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/school_filtered.csv",encoding='utf-8')
  bus_df=pd.read_excel("/content/drive/MyDrive/A하금티/data/bus_seoul_filtered.xlsx")
  shop_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/market.csv",encoding='utf-8')
  sub_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/station.csv",encoding='utf-8')
  sub_df.dropna(subset=['Latitude'],inplace=True)
  newdata=pd.read_csv("/content/drive/MyDrive/A하금티/jeonse_data_processed.csv",encoding='utf-8')

  crime_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/crime.csv",encoding='utf-8')
  police_df=pd.read_csv("/content/drive/MyDrive/A하금티/data/police_add_lo.csv",encoding='utf-8')

newdata

# 학습 데이터와 테스트 데이터 분리
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

# 선형 회귀 모델 학습
model = LinearRegression()
model.fit(X_train, Y_train)

from sklearn.metrics import mean_squared_error, r2_score,mean_absolute_error
from sklearn.model_selection import train_test_split, cross_val_score
# 예측 수행
Y_pred = model.predict(X_test)

# 평가 지표 계산
mse = mean_squared_error(Y_test, Y_pred)
mae = mean_absolute_error(Y_test, Y_pred)
r2 = r2_score(Y_test, Y_pred)
# 교차 검증
cross_val_scores = cross_val_score(model, X, Y, scoring='neg_mean_squared_error', cv=5)

print(f'Mean Squared Error (Test Set): {mse}')
print(f'Mean Absolute Error (Test Set): {mae}')
print(f'R^2 Score (Test Set): {r2}')
print(f'Mean Squared Error (Cross-Validation): {-cross_val_scores.mean()}')
print(f'Standard Deviation (Cross-Validation): {cross_val_scores.std()}')

plt.figure(figsize=(10, 6))
sns.boxplot(x=df['grfe'])
plt.title('Box Plot for Feature Outliers Detection')
plt.xlabel('Features')
plt.ylabel('Values')
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(df['grfe'], bins=20, kde=True)
plt.title('Box Plot for 보증금')
plt.xlabel('grfe')
plt.ylabel('Values')
plt.show()

"""!pip uninstall scikit-learn -y
!pip uninstall tpot -y

!pip install scikit-learn==1.5.1
!pip install tpot==0.12.2
"""

pip install numpy scipy scikit-learn pandas joblib pytorch

pip install tpot --upgrade

# 학습 데이터와 테스트 데이터 분리
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

from tpot import TPOTRegressor


# TPOTRegressor 설정 및 학습
tpot = TPOTRegressor(verbosity=2, generations=5, population_size=50)
tpot.fit(X_train, Y_train)

# 예측 및 평가
Y_pred = tpot.predict(X_test)
print(f"Mean Squared Error: {mean_squared_error(Y_test, Y_pred)}")
print(f"R^2 Score: {r2_score(Y_test, Y_pred)}")

# 베스트 파이프라인 코드 출력
tpot.export('best_model_pipeline.py')

pip install pycaret

import autosklearn.regression


# 학습 데이터와 테스트 데이터 분리
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

# Auto-sklearn Regressor 설정 및 학습
automl = autosklearn.regression.AutoSklearnRegressor(time_left_for_this_task=3600, per_run_time_limit=360)
automl.fit(X_train, Y_train)

# 예측 및 평가
Y_pred = automl.predict(X_test)
print(f"Mean Squared Error: {mean_squared_error(Y_test, Y_pred)}")
print(f"R^2 Score: {r2_score(Y_test, Y_pred)}")

# 최적 모델과 하이퍼파라미터 출력
print(automl.show_models())

pip install pycaret

from pycaret.regression import setup, compare_models, tune_model, finalize_model, predict_model

# 데이터프레임 결합 (PyCaret은 X와 Y를 하나의 데이터프레임으로 받아들입니다)
train_data = X_train.copy()
train_data['Label'] = Y_train

# PyCaret 설정
reg_setup = setup(data=train_data, target='Label', session_id=42, silent=True, use_gpu=True)

# 모델 비교
best_model = compare_models()

# 모델 튜닝
tuned_model = tune_model(best_model)

# 최종 모델 학습
final_model = finalize_model(tuned_model)

# 예측
predictions = predict_model(final_model, data=X_test)

